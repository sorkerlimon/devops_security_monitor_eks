"""
Malware Detection Module
Detects suspicious files, network activity, and potential malware threats
"""

import os
import hashlib
import json
import time
import threading
import psutil
import socket
import requests
from datetime import datetime, timedelta
from collections import defaultdict, deque
import logging
import re
from pathlib import Path
from api_client import APIClient

class MalwareDetector:
    def __init__(self, config_file=None):
        self.logger = self._setup_logging()
        self.running = False
        self.suspicious_files = []
        self.malware_signatures = set()
        self.threat_indicators = defaultdict(int)
        self.file_hashes = {}
        self.download_monitor_paths = []
        self.network_connections = deque(maxlen=1000)
        self.api_client = APIClient()
        self.alerted_files = {}  # Track recently alerted files
        
        # Configuration
        self.config = {
            'scan_interval': 30,  # seconds
            'download_paths': [
                os.path.expanduser('~/Downloads'),
                os.path.expanduser('~/Desktop'),
                'C:\\Users\\Public\\Downloads',
                'C:\\Temp'
            ],
            'suspicious_extensions': ['.exe', '.bat', '.cmd', '.scr', '.pif', '.com', '.vbs', '.js', '.jar'],
            'max_file_size': 100 * 1024 * 1024,  # 100MB
            'malware_db_file': 'malware_signatures.json',
            'threat_intelligence_url': 'https://raw.githubusercontent.com/malwaredomains/malwaredomains/master/malwaredomains.txt',
            'suspicious_domains': set(),
            'alert_threshold': 5,
            'log_file': 'malware_detector.log',
            'api_enabled': True,
            'api_username': 'admin',
            'api_password': 'admin123',
            'alert_cooldown': 300,  # 5 minutes cooldown
            'min_suspicious_score': 3  # Minimum score to trigger alert
        }
        
        if config_file and os.path.exists(config_file):
            self._load_config(config_file)
        
        self._load_malware_signatures()
        self._load_threat_intelligence()
        
        # Initialize API connection
        if self.config['api_enabled']:
            self._init_api_connection()
    
    def _setup_logging(self):
        """Setup logging for malware detection"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - MALWARE - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('malware_detector.log'),
                logging.StreamHandler()
            ]
        )
        return logging.getLogger(__name__)
    
    def _load_config(self, config_file):
        """Load configuration from JSON file"""
        try:
            with open(config_file, 'r') as f:
                config_data = json.load(f)
                self.config.update(config_data)
        except Exception as e:
            self.logger.error(f"Error loading config: {e}")
    
    def _load_malware_signatures(self):
        """Load malware signatures from database"""
        try:
            if os.path.exists(self.config['malware_db_file']):
                with open(self.config['malware_db_file'], 'r') as f:
                    data = json.load(f)
                    self.malware_signatures = set(data.get('signatures', []))
                    self.logger.info(f"Loaded {len(self.malware_signatures)} malware signatures")
        except Exception as e:
            self.logger.error(f"Error loading malware signatures: {e}")
    
    def _load_threat_intelligence(self):
        """Load threat intelligence from external sources"""
        try:
            # Load known malicious domains
            response = requests.get(self.config['threat_intelligence_url'], timeout=10)
            if response.status_code == 200:
                domains = response.text.strip().split('\n')
                self.config['suspicious_domains'] = set(domain.strip() for domain in domains if domain.strip())
                self.logger.info(f"Loaded {len(self.config['suspicious_domains'])} suspicious domains")
        except Exception as e:
            self.logger.warning(f"Could not load threat intelligence: {e}")
    
    def _init_api_connection(self):
        """Initialize API connection"""
        try:
            if self.api_client.login(self.config['api_username'], self.config['api_password']):
                self.logger.info("API connection established")
            else:
                self.logger.warning("Failed to connect to API")
        except Exception as e:
            self.logger.error(f"API connection error: {e}")
    
    def _send_to_api(self, report_data):
        """Send report data to API"""
        if not self.config['api_enabled']:
            return
        
        try:
            self.api_client.send_malware_report(report_data)
        except Exception as e:
            self.logger.error(f"Error sending to API: {e}")
    
    def _should_alert_file(self, file_path):
        """Check if we should alert for this file (cooldown)"""
        current_time = time.time()
        if file_path in self.alerted_files:
            last_alert = self.alerted_files[file_path]
            if current_time - last_alert < self.config['alert_cooldown']:
                return False
        
        self.alerted_files[file_path] = current_time
        return True
    
    def calculate_file_hash(self, file_path):
        """Calculate MD5 and SHA256 hashes of a file"""
        try:
            hash_md5 = hashlib.md5()
            hash_sha256 = hashlib.sha256()
            
            with open(file_path, "rb") as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    hash_md5.update(chunk)
                    hash_sha256.update(chunk)
            
            return {
                'md5': hash_md5.hexdigest(),
                'sha256': hash_sha256.hexdigest()
            }
        except Exception as e:
            self.logger.error(f"Error calculating hash for {file_path}: {e}")
            return None
    
    def scan_file(self, file_path):
        """Scan a single file for malware indicators"""
        try:
            if not os.path.exists(file_path):
                return None
            
            file_info = {
                'path': file_path,
                'size': os.path.getsize(file_path),
                'modified': datetime.fromtimestamp(os.path.getmtime(file_path)).isoformat(),
                'suspicious_score': 0,
                'indicators': []
            }
            
            # Check file extension
            file_ext = os.path.splitext(file_path)[1].lower()
            if file_ext in self.config['suspicious_extensions']:
                file_info['suspicious_score'] += 2
                file_info['indicators'].append(f"Suspicious extension: {file_ext}")
            
            # Check file size
            if file_info['size'] > self.config['max_file_size']:
                file_info['suspicious_score'] += 1
                file_info['indicators'].append(f"Large file size: {file_info['size']} bytes")
            
            # Calculate and check hashes
            hashes = self.calculate_file_hash(file_path)
            if hashes:
                file_info['hashes'] = hashes
                
                # Check against known malware signatures
                if hashes['md5'] in self.malware_signatures or hashes['sha256'] in self.malware_signatures:
                    file_info['suspicious_score'] += 10
                    file_info['indicators'].append("Known malware signature detected")
                    file_info['malware_detected'] = True
            
            # Check filename patterns
            filename = os.path.basename(file_path).lower()
            suspicious_patterns = [
                r'\.exe\.exe$',  # Double extension
                r'^[a-f0-9]{32,}\.',  # Random hash-like names
                r'\.(tmp|temp)\.exe$',  # Temp files with exe
                r'^[a-z]{1,3}\.exe$',  # Very short names
                r'\.(scr|pif|com)$'  # Suspicious extensions
            ]
            
            for pattern in suspicious_patterns:
                if re.search(pattern, filename):
                    file_info['suspicious_score'] += 3
                    file_info['indicators'].append(f"Suspicious filename pattern: {pattern}")
            
            return file_info
            
        except Exception as e:
            self.logger.error(f"Error scanning file {file_path}: {e}")
            return None
    
    def monitor_downloads(self):
        """Monitor download directories for new files"""
        for download_path in self.config['download_paths']:
            if os.path.exists(download_path):
                try:
                    for root, dirs, files in os.walk(download_path):
                        for file in files:
                            file_path = os.path.join(root, file)
                            file_info = self.scan_file(file_path)
                            
                            if file_info and file_info['suspicious_score'] >= self.config['min_suspicious_score'] and self._should_alert_file(file_path):
                                self.suspicious_files.append(file_info)
                                self.logger.warning(f"Suspicious file detected: {file_path}")
                                self.logger.warning(f"Score: {file_info['suspicious_score']}, Indicators: {file_info['indicators']}")
                                
                                # Send to API
                                api_data = {
                                    'file_path': file_info['path'],
                                    'file_name': os.path.basename(file_info['path']),
                                    'file_size': file_info['size'],
                                    'file_hash_md5': file_info.get('hashes', {}).get('md5'),
                                    'file_hash_sha256': file_info.get('hashes', {}).get('sha256'),
                                    'suspicious_score': file_info['suspicious_score'],
                                    'malware_detected': file_info.get('malware_detected', False),
                                    'indicators': json.dumps(file_info['indicators']),
                                    'status': 'detected'
                                }
                                self._send_to_api(api_data)
                                
                                if file_info.get('malware_detected'):
                                    self.logger.critical(f"MALWARE DETECTED: {file_path}")
                                
                except Exception as e:
                    self.logger.error(f"Error monitoring {download_path}: {e}")
    
    def analyze_network_connections(self):
        """Analyze network connections for suspicious activity"""
        try:
            connections = psutil.net_connections(kind='inet')
            suspicious_connections = []
            
            for conn in connections:
                if conn.raddr and conn.status == 'ESTABLISHED':
                    remote_ip = conn.raddr.ip
                    remote_port = conn.raddr.port
                    
                    # Check for suspicious ports
                    suspicious_ports = [4444, 6666, 6667, 6668, 6669, 31337, 12345, 54321]
                    if remote_port in suspicious_ports:
                        suspicious_connections.append({
                            'type': 'suspicious_port',
                            'local': f"{conn.laddr.ip}:{conn.laddr.port}",
                            'remote': f"{remote_ip}:{remote_port}",
                            'pid': conn.pid,
                            'process': psutil.Process(conn.pid).name() if conn.pid else None
                        })
                    
                    # Check for connections to suspicious domains
                    try:
                        hostname = socket.gethostbyaddr(remote_ip)[0]
                        if any(domain in hostname.lower() for domain in self.config['suspicious_domains']):
                            suspicious_connections.append({
                                'type': 'suspicious_domain',
                                'local': f"{conn.laddr.ip}:{conn.laddr.port}",
                                'remote': f"{hostname} ({remote_ip}:{remote_port})",
                                'pid': conn.pid,
                                'process': psutil.Process(conn.pid).name() if conn.pid else None
                            })
                    except:
                        pass
                    
                    # Check for high frequency connections
                    conn_key = f"{conn.laddr.ip}:{conn.laddr.port}-{remote_ip}:{remote_port}"
                    self.network_connections.append({
                        'key': conn_key,
                        'timestamp': datetime.now(),
                        'pid': conn.pid
                    })
            
            # Analyze connection frequency
            recent_connections = [c for c in self.network_connections 
                                if c['timestamp'] > datetime.now() - timedelta(minutes=5)]
            
            connection_counts = defaultdict(int)
            for conn in recent_connections:
                connection_counts[conn['key']] += 1
            
            for conn_key, count in connection_counts.items():
                if count > 50:  # More than 50 connections in 5 minutes
                    suspicious_connections.append({
                        'type': 'high_frequency',
                        'connection': conn_key,
                        'count': count,
                        'timeframe': '5 minutes'
                    })
            
            return suspicious_connections
            
        except Exception as e:
            self.logger.error(f"Error analyzing network connections: {e}")
            return []
    
    def detect_process_anomalies(self):
        """Detect suspicious process behavior"""
        try:
            suspicious_processes = []
            processes = list(psutil.process_iter(['pid', 'name', 'exe', 'cmdline', 'create_time']))
            
            for proc in processes:
                try:
                    proc_info = proc.info
                    
                    # Check for processes with suspicious names
                    suspicious_names = [
                        'svchost.exe', 'explorer.exe', 'winlogon.exe', 'csrss.exe',
                        'lsass.exe', 'services.exe', 'smss.exe'
                    ]
                    
                    if proc_info['name'] and proc_info['name'].lower() in suspicious_names:
                        # Check if multiple instances exist
                        same_name_procs = [p for p in processes if p.info['name'] == proc_info['name']]
                        if len(same_name_procs) > 3:
                            suspicious_processes.append({
                                'type': 'multiple_system_processes',
                                'process': proc_info['name'],
                                'count': len(same_name_procs),
                                'pids': [p.info['pid'] for p in same_name_procs]
                            })
                    
                    # Check for processes with suspicious command lines
                    if proc_info['cmdline']:
                        cmdline = ' '.join(proc_info['cmdline']).lower()
                        suspicious_patterns = [
                            'powershell -enc',  # Encoded PowerShell
                            'cmd /c',  # Command execution
                            'rundll32',  # DLL execution
                            'regsvr32',  # DLL registration
                            'wscript',  # Script execution
                            'cscript'   # Script execution
                        ]
                        
                        for pattern in suspicious_patterns:
                            if pattern in cmdline:
                                suspicious_processes.append({
                                    'type': 'suspicious_command',
                                    'process': proc_info['name'],
                                    'pid': proc_info['pid'],
                                    'command': cmdline,
                                    'pattern': pattern
                                })
                
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            
            return suspicious_processes
            
        except Exception as e:
            self.logger.error(f"Error detecting process anomalies: {e}")
            return []
    
    def run_detection(self):
        """Run comprehensive malware detection"""
        self.running = True
        self.logger.info("Starting malware detection")
        
        try:
            while self.running:
                # Monitor downloads
                self.monitor_downloads()
                
                # Analyze network connections
                network_threats = self.analyze_network_connections()
                for threat in network_threats:
                    self.logger.warning(f"Network threat detected: {threat}")
                
                # Detect process anomalies
                process_threats = self.detect_process_anomalies()
                for threat in process_threats:
                    self.logger.warning(f"Process anomaly detected: {threat}")
                
                # Update threat indicators
                total_threats = len(network_threats) + len(process_threats)
                if total_threats > 0:
                    self.threat_indicators[datetime.now().strftime('%Y-%m-%d %H:%M')] = total_threats
                
                time.sleep(self.config['scan_interval'])
                
        except KeyboardInterrupt:
            self.logger.info("Malware detection stopped by user")
        except Exception as e:
            self.logger.error(f"Error during malware detection: {e}")
        finally:
            self.running = False
    
    def get_detection_report(self):
        """Get current detection report"""
        return {
            'timestamp': datetime.now().isoformat(),
            'suspicious_files': self.suspicious_files[-50:],  # Last 50 files
            'threat_indicators': dict(self.threat_indicators),
            'malware_signatures_count': len(self.malware_signatures),
            'suspicious_domains_count': len(self.config['suspicious_domains']),
            'total_network_connections': len(self.network_connections)
        }
    
    def stop(self):
        """Stop malware detection"""
        self.running = False
